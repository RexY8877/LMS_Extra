const NodeClam = require('clamscan');
const fs = require('fs').promises;
const path = require('path');

/**
 * Malware scanning service using ClamAV
 */
class MalwareScanService {
  constructor() {
    this.clamscan = null;
    this.isInitialized = false;
    this.initializationPromise = null;
  }

  /**
   * Initialize ClamAV scanner
   * @returns {Promise<void>}
   */
  async initialize() {
    if (this.isInitialized) {
      return;
    }

    if (this.initializationPromise) {
      return this.initializationPromise;
    }

    this.initializationPromise = this._initializeScanner();
    await this.initializationPromise;
  }

  async _initializeScanner() {
    try {
      // ClamAV configuration
      const clamConfig = {
        removeInfected: false, // Don't automatically remove infected files
        quarantineInfected: false, // Don't quarantine infected files
        scanLog: null, // Disable scan logging for now
        debugMode: process.env.NODE_ENV === 'development',
        fileList: null,
        scanRecursively: false,
        clamscan: {
          path: process.env.CLAMSCAN_PATH || '/usr/bin/clamscan', // Path to clamscan binary
          db: process.env.CLAMAV_DB_PATH || null, // Path to virus database
          scanArchives: true,
          active: true
        },
        clamdscan: {
          socket: process.env.CLAMD_SOCKET || '/var/run/clamav/clamd.ctl',
          host: process.env.CLAMD_HOST || '127.0.0.1',
          port: process.env.CLAMD_PORT || 3310,
          timeout: 60000,
          localFallback: true, // Fallback to clamscan if clamd is not available
          active: true
        },
        preference: 'clamdscan' // Prefer daemon over binary
      };

      this.clamscan = await new NodeClam().init(clamConfig);
      this.isInitialized = true;
      
      console.log('ClamAV scanner initialized successfully');
    } catch (error) {
      console.warn('ClamAV initialization failed:', error.message);
      console.warn('Malware scanning will be disabled');
      
      // Create a mock scanner for development/testing
      this.clamscan = {
        scanBuffer: async () => ({ isInfected: false, viruses: [] }),
        scanFile: async () => ({ isInfected: false, viruses: [] }),
        isAvailable: () => false
      };
      this.isInitialized = true;
    }
  }

  /**
   * Scan a file buffer for malware
   * @param {Buffer} buffer - File buffer to scan
   * @param {string} filename - Original filename for context
   * @returns {Promise<Object>} Scan result
   */
  async scanBuffer(buffer, filename = 'unknown') {
    await this.initialize();

    try {
      const result = await this.clamscan.scanBuffer(buffer);
      
      return {
        isClean: !result.isInfected,
        isInfected: result.isInfected,
        viruses: result.viruses || [],
        filename,
        scanTime: new Date().toISOString()
      };
    } catch (error) {
      console.error('Malware scan failed:', error);
      
      // In case of scan failure, err on the side of caution
      return {
        isClean: false,
        isInfected: false,
        viruses: [],
        error: error.message,
        filename,
        scanTime: new Date().toISOString()
      };
    }
  }

  /**
   * Scan a file on disk for malware
   * @param {string} filePath - Path to file to scan
   * @returns {Promise<Object>} Scan result
   */
  async scanFile(filePath) {
    await this.initialize();

    try {
      const result = await this.clamscan.scanFile(filePath);
      const filename = path.basename(filePath);
      
      return {
        isClean: !result.isInfected,
        isInfected: result.isInfected,
        viruses: result.viruses || [],
        filename,
        filePath,
        scanTime: new Date().toISOString()
      };
    } catch (error) {
      console.error('Malware scan failed:', error);
      
      return {
        isClean: false,
        isInfected: false,
        viruses: [],
        error: error.message,
        filename: path.basename(filePath),
        filePath,
        scanTime: new Date().toISOString()
      };
    }
  }

  /**
   * Check if ClamAV scanner is available and working
   * @returns {Promise<boolean>}
   */
  async isAvailable() {
    await this.initialize();
    
    try {
      return this.clamscan.isAvailable && this.clamscan.isAvailable();
    } catch (error) {
      return false;
    }
  }

  /**
   * Get scanner version information
   * @returns {Promise<Object>}
   */
  async getVersion() {
    await this.initialize();
    
    try {
      const version = await this.clamscan.getVersion();
      return {
        version,
        available: await this.isAvailable()
      };
    } catch (error) {
      return {
        version: 'Unknown',
        available: false,
        error: error.message
      };
    }
  }

  /**
   * Validate scan result and throw error if infected
   * @param {Object} scanResult - Result from scanBuffer or scanFile
   * @throws {Error} If file is infected
   */
  validateScanResult(scanResult) {
    if (scanResult.error) {
      throw new Error(`Malware scan failed: ${scanResult.error}`);
    }

    if (scanResult.isInfected) {
      const virusList = scanResult.viruses.join(', ');
      throw new Error(`File is infected with malware: ${virusList}`);
    }

    if (!scanResult.isClean && !scanResult.isInfected) {
      // Scan was inconclusive - reject for safety
      throw new Error('Malware scan was inconclusive - file rejected for security');
    }
  }
}

// Singleton instance
let malwareScanService = null;

/**
 * Get singleton instance of malware scan service
 * @returns {MalwareScanService}
 */
function getMalwareScanService() {
  if (!malwareScanService) {
    malwareScanService = new MalwareScanService();
  }
  return malwareScanService;
}

module.exports = {
  MalwareScanService,
  getMalwareScanService
};